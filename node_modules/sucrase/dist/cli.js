"use strict"; function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } } function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }Object.defineProperty(exports, "__esModule", {value: true});/* eslint-disable no-console */
var _commander = require('commander'); var _commander2 = _interopRequireDefault(_commander);
var _fs = require('mz/fs');
var _path = require('path');

var _index = require('./index');

 function run() {
  _commander2.default
    .description(`Sucrase: super-fast Babel alternative.`)
    .usage("[options] <srcDir>")
    .option(
      "-d, --out-dir <out>",
      "Compile an input directory of modules into an output directory.",
    )
    .option("--exclude-dirs <paths>", "Names of directories that should not be traversed.")
    .option("-t, --transforms <transforms>", "Comma-separated list of transforms to run.")
    .option(
      "--enable-legacy-typescript-module-interop",
      "Use default TypeScript ESM/CJS interop strategy.",
    )
    .option("--enable-legacy-babel5-module-interop", "Use Babel 5 ESM/CJS interop strategy.")
    .parse(process.argv);

  if (!_commander2.default.outDir) {
    console.error("Out directory is required");
    process.exit(1);
  }

  if (!_commander2.default.transforms) {
    console.error("Transforms option is required.");
    process.exit(1);
  }

  if (!_commander2.default.args[0]) {
    console.error("Source directory is required.");
    process.exit(1);
  }

  const outDir = _commander2.default.outDir;
  const srcDir = _commander2.default.args[0];
  const excludeDirs = _commander2.default.excludeDirs ? _commander2.default.excludeDirs.split(",") : [];

  const options = {
    transforms: _commander2.default.transforms.split(","),
    enableLegacyTypeScriptModuleInterop: _commander2.default.enableLegacyTypescriptModuleInterop,
    enableLegacyBabel5ModuleInterop: _commander2.default.enableLegacyBabel5ModuleInterop,
  };

  buildDirectory(srcDir, outDir, excludeDirs, options).catch((e) => {
    process.exitCode = 1;
    console.error(e);
  });
} exports.default = run;

async function buildDirectory(
  srcDirPath,
  outDirPath,
  excludeDirs,
  options,
) {
  const extension = options.transforms.includes("typescript") ? ".ts" : ".js";
  if (!(await (0, _fs.exists)(outDirPath))) {
    await (0, _fs.mkdir)(outDirPath);
  }
  for (const child of await (0, _fs.readdir)(srcDirPath)) {
    if (["node_modules", ".git"].includes(child) || excludeDirs.includes(child)) {
      continue;
    }
    const srcChildPath = (0, _path.join)(srcDirPath, child);
    const outChildPath = (0, _path.join)(outDirPath, child);
    if ((await (0, _fs.stat)(srcChildPath)).isDirectory()) {
      await buildDirectory(srcChildPath, outChildPath, excludeDirs, options);
    } else if (srcChildPath.endsWith(extension)) {
      const outPath = `${outChildPath.substr(0, outChildPath.length - 3)}.js`;
      await buildFile(srcChildPath, outPath, options);
    }
  }
}

async function buildFile(srcPath, outPath, options) {
  console.log(`${srcPath} -> ${outPath}`);
  const code = (await (0, _fs.readFile)(srcPath)).toString();
  const transformedCode = (0, _index.transform)(code, {...options, filePath: srcPath}).code;
  await (0, _fs.writeFile)(outPath, transformedCode);
}
