import CJSImportProcessor from "../CJSImportProcessor";
import TokenProcessor from "../TokenProcessor";
import RootTransformer from "./RootTransformer";
import Transformer from "./Transformer";
/**
 * Class for editing import statements when we are transforming to commonjs.
 */
export default class CJSImportTransformer extends Transformer {
    readonly rootTransformer: RootTransformer;
    readonly tokens: TokenProcessor;
    readonly importProcessor: CJSImportProcessor;
    readonly enableLegacyBabel5ModuleInterop: boolean;
    private hadExport;
    private hadNamedExport;
    private hadDefaultExport;
    constructor(rootTransformer: RootTransformer, tokens: TokenProcessor, importProcessor: CJSImportProcessor, enableLegacyBabel5ModuleInterop: boolean);
    getPrefixCode(): string;
    getSuffixCode(): string;
    process(): boolean;
    /**
     * Transform this:
     * import foo, {bar} from 'baz';
     * into
     * var _baz = require('baz'); var _baz2 = _interopRequireDefault(_baz);
     *
     * The import code was already generated in the import preprocessing step, so
     * we just need to look it up.
     */
    private processImport;
    /**
     * Erase this import, and return true if it was either of the form "import type" or contained only
     * "type" named imports. Such imports should not even do a side-effect import.
     *
     * The position should end at the import string.
     */
    private removeImportAndDetectIfType;
    private removeRemainingImport;
    private processIdentifier;
    processObjectShorthand(): boolean;
    processExport(): boolean;
    private processAssignment;
    private processExportDefault;
    /**
     * Transform this:
     * export const x = 1;
     * into this:
     * exports.x = 1;
     */
    private processExportVar;
    /**
     * Transform this:
     * export function foo() {}
     * into this:
     * function foo() {} exports.foo = foo;
     */
    private processExportFunction;
    /**
     * Skip past a function with a name and return that name.
     */
    private processNamedFunction;
    /**
     * Transform this:
     * export class A {}
     * into this:
     * class A {} exports.A = A;
     */
    private processExportClass;
    /**
     * Transform this:
     * export {a, b as c};
     * into this:
     * exports.a = a; exports.c = b;
     *
     * OR
     *
     * Transform this:
     * export {a, b as c} from './foo';
     * into the pre-generated Object.defineProperty code from the ImportProcessor.
     */
    private processExportBindings;
    private processExportStar;
}
