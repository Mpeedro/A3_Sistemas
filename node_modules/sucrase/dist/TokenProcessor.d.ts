import { ContextualKeyword, Token } from "./parser/tokenizer";
import { TokenType } from "./parser/tokenizer/types";
export declare type TokenProcessorSnapshot = {
    resultCode: string;
    tokenIndex: number;
};
export default class TokenProcessor {
    readonly code: string;
    readonly tokens: Array<Token>;
    private resultCode;
    private tokenIndex;
    constructor(code: string, tokens: Array<Token>);
    /**
     * Make a new TokenProcessor for things like lookahead.
     */
    snapshot(): TokenProcessorSnapshot;
    restoreToSnapshot(snapshot: TokenProcessorSnapshot): void;
    getResultCodeIndex(): number;
    getCodeInsertedSinceIndex(initialResultCodeIndex: number): string;
    reset(): void;
    matchesAtIndex(index: number, types: Array<TokenType>): boolean;
    matchesContextualAtIndex(index: number, contextualKeyword: ContextualKeyword): boolean;
    identifierNameAtIndex(index: number): string;
    identifierName(): string;
    identifierNameForToken(token: Token): string;
    stringValueAtIndex(index: number): string;
    stringValue(): string;
    stringValueForToken(token: Token): string;
    matches1(t1: TokenType): boolean;
    matches2(t1: TokenType, t2: TokenType): boolean;
    matches3(t1: TokenType, t2: TokenType, t3: TokenType): boolean;
    matches4(t1: TokenType, t2: TokenType, t3: TokenType, t4: TokenType): boolean;
    matches5(t1: TokenType, t2: TokenType, t3: TokenType, t4: TokenType, t5: TokenType): boolean;
    matchesContextual(contextualKeyword: ContextualKeyword): boolean;
    matchesContextIdAndLabel(type: TokenType, contextId: number): boolean;
    previousWhitespace(): string;
    replaceToken(newCode: string): void;
    replaceTokenTrimmingLeftWhitespace(newCode: string): void;
    removeInitialToken(): void;
    removeToken(): void;
    copyExpectedToken(tokenType: TokenType): void;
    copyToken(): void;
    appendCode(code: string): void;
    currentToken(): Token;
    currentTokenCode(): string;
    tokenAtRelativeIndex(relativeIndex: number): Token;
    currentIndex(): number;
    /**
     * Move to the next token. Only suitable in preprocessing steps. When
     * generating new code, you should use copyToken or removeToken.
     */
    nextToken(): void;
    previousToken(): void;
    finish(): string;
    isAtEnd(): boolean;
}
