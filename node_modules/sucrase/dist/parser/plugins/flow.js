"use strict"; function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } } function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }Object.defineProperty(exports, "__esModule", {value: true});/* eslint max-len: 0 */











var _index = require('../tokenizer/index');
var _types = require('../tokenizer/types');
var _base = require('../traverser/base');










var _expression = require('../traverser/expression');








var _statement = require('../traverser/statement');









var _util = require('../traverser/util');

function isMaybeDefaultImport(lookahead) {
  return (
    (lookahead.type === _types.TokenType.name || !!(lookahead.type & _types.TokenType.IS_KEYWORD)) &&
    lookahead.contextualKeyword !== _index.ContextualKeyword._from
  );
}

function flowParseTypeInitialiser(tok) {
  const oldIsType = (0, _index.pushTypeContext)(0);
  (0, _util.expect)(tok || _types.TokenType.colon);
  flowParseType();
  (0, _index.popTypeContext)(oldIsType);
}

function flowParsePredicate() {
  (0, _util.expect)(_types.TokenType.modulo);
  (0, _util.expectContextual)(_index.ContextualKeyword._checks);
  if ((0, _index.eat)(_types.TokenType.parenL)) {
    (0, _expression.parseExpression)();
    (0, _util.expect)(_types.TokenType.parenR);
  }
}

function flowParseTypeAndPredicateInitialiser() {
  const oldIsType = (0, _index.pushTypeContext)(0);
  (0, _util.expect)(_types.TokenType.colon);
  if ((0, _index.match)(_types.TokenType.modulo)) {
    flowParsePredicate();
  } else {
    flowParseType();
    if ((0, _index.match)(_types.TokenType.modulo)) {
      flowParsePredicate();
    }
  }
  (0, _index.popTypeContext)(oldIsType);
}

function flowParseDeclareClass() {
  (0, _index.next)();
  flowParseInterfaceish(/* isClass */ true);
}

function flowParseDeclareFunction() {
  (0, _index.next)();
  (0, _expression.parseIdentifier)();

  if ((0, _index.match)(_types.TokenType.lessThan)) {
    flowParseTypeParameterDeclaration();
  }

  (0, _util.expect)(_types.TokenType.parenL);
  flowParseFunctionTypeParams();
  (0, _util.expect)(_types.TokenType.parenR);

  flowParseTypeAndPredicateInitialiser();

  (0, _util.semicolon)();
}

function flowParseDeclare() {
  if ((0, _index.match)(_types.TokenType._class)) {
    flowParseDeclareClass();
  } else if ((0, _index.match)(_types.TokenType._function)) {
    flowParseDeclareFunction();
  } else if ((0, _index.match)(_types.TokenType._var)) {
    flowParseDeclareVariable();
  } else if ((0, _util.isContextual)(_index.ContextualKeyword._module)) {
    if ((0, _index.lookaheadType)() === _types.TokenType.dot) {
      flowParseDeclareModuleExports();
    } else {
      flowParseDeclareModule();
    }
  } else if ((0, _util.isContextual)(_index.ContextualKeyword._type)) {
    flowParseDeclareTypeAlias();
  } else if ((0, _util.isContextual)(_index.ContextualKeyword._opaque)) {
    flowParseDeclareOpaqueType();
  } else if ((0, _util.isContextual)(_index.ContextualKeyword._interface)) {
    flowParseDeclareInterface();
  } else if ((0, _index.match)(_types.TokenType._export)) {
    flowParseDeclareExportDeclaration();
  } else {
    throw (0, _util.unexpected)();
  }
}

function flowParseDeclareVariable() {
  (0, _index.next)();
  flowParseTypeAnnotatableIdentifier();
  (0, _util.semicolon)();
}

function flowParseDeclareModule() {
  (0, _index.next)();

  if ((0, _index.match)(_types.TokenType.string)) {
    (0, _expression.parseExprAtom)();
  } else {
    (0, _expression.parseIdentifier)();
  }

  (0, _util.expect)(_types.TokenType.braceL);
  while (!(0, _index.match)(_types.TokenType.braceR)) {
    if ((0, _index.match)(_types.TokenType._import)) {
      (0, _index.next)();
      (0, _statement.parseImport)();
    }
  }
  (0, _util.expect)(_types.TokenType.braceR);
}

function flowParseDeclareExportDeclaration() {
  (0, _util.expect)(_types.TokenType._export);

  if ((0, _index.eat)(_types.TokenType._default)) {
    if ((0, _index.match)(_types.TokenType._function) || (0, _index.match)(_types.TokenType._class)) {
      // declare export default class ...
      // declare export default function ...
      flowParseDeclare();
    } else {
      // declare export default [type];
      flowParseType();
      (0, _util.semicolon)();
    }
  } else if (
    (0, _index.match)(_types.TokenType._var) || // declare export var ...
    (0, _index.match)(_types.TokenType._function) || // declare export function ...
    (0, _index.match)(_types.TokenType._class) || // declare export class ...
    (0, _util.isContextual)(_index.ContextualKeyword._opaque) // declare export opaque ..
  ) {
    flowParseDeclare();
  } else if (
    (0, _index.match)(_types.TokenType.star) || // declare export * from ''
    (0, _index.match)(_types.TokenType.braceL) || // declare export {} ...
    (0, _util.isContextual)(_index.ContextualKeyword._interface) || // declare export interface ...
    (0, _util.isContextual)(_index.ContextualKeyword._type) || // declare export type ...
    (0, _util.isContextual)(_index.ContextualKeyword._opaque) // declare export opaque type ...
  ) {
    (0, _statement.parseExport)();
  } else {
    throw (0, _util.unexpected)();
  }
}

function flowParseDeclareModuleExports() {
  (0, _util.expectContextual)(_index.ContextualKeyword._module);
  (0, _util.expect)(_types.TokenType.dot);
  (0, _util.expectContextual)(_index.ContextualKeyword._exports);
  flowParseTypeAnnotation();
  (0, _util.semicolon)();
}

function flowParseDeclareTypeAlias() {
  (0, _index.next)();
  flowParseTypeAlias();
}

function flowParseDeclareOpaqueType() {
  (0, _index.next)();
  flowParseOpaqueType(true);
}

function flowParseDeclareInterface() {
  (0, _index.next)();
  flowParseInterfaceish();
}

// Interfaces

function flowParseInterfaceish(isClass) {
  flowParseRestrictedIdentifier();

  if ((0, _index.match)(_types.TokenType.lessThan)) {
    flowParseTypeParameterDeclaration();
  }

  if ((0, _index.eat)(_types.TokenType._extends)) {
    do {
      flowParseInterfaceExtends();
    } while (!isClass && (0, _index.eat)(_types.TokenType.comma));
  }

  if ((0, _util.isContextual)(_index.ContextualKeyword._mixins)) {
    (0, _index.next)();
    do {
      flowParseInterfaceExtends();
    } while ((0, _index.eat)(_types.TokenType.comma));
  }

  if ((0, _util.isContextual)(_index.ContextualKeyword._implements)) {
    (0, _index.next)();
    do {
      flowParseInterfaceExtends();
    } while ((0, _index.eat)(_types.TokenType.comma));
  }

  flowParseObjectType(true, false);
}

function flowParseInterfaceExtends() {
  flowParseQualifiedTypeIdentifier(false);
  if ((0, _index.match)(_types.TokenType.lessThan)) {
    flowParseTypeParameterInstantiation();
  }
}

function flowParseInterface() {
  flowParseInterfaceish();
}

function flowParseRestrictedIdentifier() {
  (0, _expression.parseIdentifier)();
}

function flowParseTypeAlias() {
  flowParseRestrictedIdentifier();

  if ((0, _index.match)(_types.TokenType.lessThan)) {
    flowParseTypeParameterDeclaration();
  }

  flowParseTypeInitialiser(_types.TokenType.eq);
  (0, _util.semicolon)();
}

function flowParseOpaqueType(declare) {
  (0, _util.expectContextual)(_index.ContextualKeyword._type);
  flowParseRestrictedIdentifier();

  if ((0, _index.match)(_types.TokenType.lessThan)) {
    flowParseTypeParameterDeclaration();
  }

  // Parse the supertype
  if ((0, _index.match)(_types.TokenType.colon)) {
    flowParseTypeInitialiser(_types.TokenType.colon);
  }

  if (!declare) {
    flowParseTypeInitialiser(_types.TokenType.eq);
  }
  (0, _util.semicolon)();
}

function flowParseTypeParameter() {
  flowParseVariance();
  flowParseTypeAnnotatableIdentifier();

  if ((0, _index.eat)(_types.TokenType.eq)) {
    flowParseType();
  }
}

 function flowParseTypeParameterDeclaration() {
  const oldIsType = (0, _index.pushTypeContext)(0);
  // istanbul ignore else: this condition is already checked at all call sites
  if ((0, _index.match)(_types.TokenType.lessThan) || (0, _index.match)(_types.TokenType.typeParameterStart)) {
    (0, _index.next)();
  } else {
    (0, _util.unexpected)();
  }

  do {
    flowParseTypeParameter();
    if (!(0, _index.match)(_types.TokenType.greaterThan)) {
      (0, _util.expect)(_types.TokenType.comma);
    }
  } while (!(0, _index.match)(_types.TokenType.greaterThan));
  (0, _util.expect)(_types.TokenType.greaterThan);
  (0, _index.popTypeContext)(oldIsType);
} exports.flowParseTypeParameterDeclaration = flowParseTypeParameterDeclaration;

function flowParseTypeParameterInstantiation() {
  const oldIsType = (0, _index.pushTypeContext)(0);
  (0, _util.expect)(_types.TokenType.lessThan);
  while (!(0, _index.match)(_types.TokenType.greaterThan)) {
    flowParseType();
    if (!(0, _index.match)(_types.TokenType.greaterThan)) {
      (0, _util.expect)(_types.TokenType.comma);
    }
  }
  (0, _util.expect)(_types.TokenType.greaterThan);
  (0, _index.popTypeContext)(oldIsType);
}

function flowParseObjectPropertyKey() {
  if ((0, _index.match)(_types.TokenType.num) || (0, _index.match)(_types.TokenType.string)) {
    (0, _expression.parseExprAtom)();
  } else {
    (0, _expression.parseIdentifier)();
  }
}

function flowParseObjectTypeIndexer() {
  (0, _util.expect)(_types.TokenType.bracketL);
  if ((0, _index.lookaheadType)() === _types.TokenType.colon) {
    flowParseObjectPropertyKey();
    flowParseTypeInitialiser();
  } else {
    flowParseType();
  }
  (0, _util.expect)(_types.TokenType.bracketR);
  flowParseTypeInitialiser();
}

function flowParseObjectTypeMethodish() {
  if ((0, _index.match)(_types.TokenType.lessThan)) {
    flowParseTypeParameterDeclaration();
  }

  (0, _util.expect)(_types.TokenType.parenL);
  while (!(0, _index.match)(_types.TokenType.parenR) && !(0, _index.match)(_types.TokenType.ellipsis)) {
    flowParseFunctionTypeParam();
    if (!(0, _index.match)(_types.TokenType.parenR)) {
      (0, _util.expect)(_types.TokenType.comma);
    }
  }

  if ((0, _index.eat)(_types.TokenType.ellipsis)) {
    flowParseFunctionTypeParam();
  }
  (0, _util.expect)(_types.TokenType.parenR);
  flowParseTypeInitialiser();
}

function flowParseObjectTypeCallProperty() {
  flowParseObjectTypeMethodish();
}

function flowParseObjectType(allowStatic, allowExact) {
  let endDelim;
  if (allowExact && (0, _index.match)(_types.TokenType.braceBarL)) {
    (0, _util.expect)(_types.TokenType.braceBarL);
    endDelim = _types.TokenType.braceBarR;
  } else {
    (0, _util.expect)(_types.TokenType.braceL);
    endDelim = _types.TokenType.braceR;
  }

  while (!(0, _index.match)(endDelim)) {
    if (allowStatic && (0, _util.isContextual)(_index.ContextualKeyword._static) && (0, _index.lookaheadType)() !== _types.TokenType.colon) {
      (0, _index.next)();
    }

    flowParseVariance();

    if ((0, _index.match)(_types.TokenType.bracketL)) {
      flowParseObjectTypeIndexer();
    } else if ((0, _index.match)(_types.TokenType.parenL) || (0, _index.match)(_types.TokenType.lessThan)) {
      flowParseObjectTypeCallProperty();
    } else {
      if ((0, _util.isContextual)(_index.ContextualKeyword._get) || (0, _util.isContextual)(_index.ContextualKeyword._set)) {
        const lookahead = (0, _index.lookaheadType)();
        if (lookahead === _types.TokenType.name || lookahead === _types.TokenType.string || lookahead === _types.TokenType.num) {
          (0, _index.next)();
        }
      }

      flowParseObjectTypeProperty();
    }

    flowObjectTypeSemicolon();
  }

  (0, _util.expect)(endDelim);
}

function flowParseObjectTypeProperty() {
  if ((0, _index.match)(_types.TokenType.ellipsis)) {
    (0, _util.expect)(_types.TokenType.ellipsis);
    flowParseType();
  } else {
    flowParseObjectPropertyKey();
    if ((0, _index.match)(_types.TokenType.lessThan) || (0, _index.match)(_types.TokenType.parenL)) {
      // This is a method property
      flowParseObjectTypeMethodish();
    } else {
      (0, _index.eat)(_types.TokenType.question);
      flowParseTypeInitialiser();
    }
  }
}

function flowObjectTypeSemicolon() {
  if (!(0, _index.eat)(_types.TokenType.semi) && !(0, _index.eat)(_types.TokenType.comma) && !(0, _index.match)(_types.TokenType.braceR) && !(0, _index.match)(_types.TokenType.braceBarR)) {
    (0, _util.unexpected)();
  }
}

function flowParseQualifiedTypeIdentifier(initialIdAlreadyParsed) {
  if (!initialIdAlreadyParsed) {
    (0, _expression.parseIdentifier)();
  }
  while ((0, _index.eat)(_types.TokenType.dot)) {
    (0, _expression.parseIdentifier)();
  }
}

function flowParseGenericType() {
  flowParseQualifiedTypeIdentifier(true);
  if ((0, _index.match)(_types.TokenType.lessThan)) {
    flowParseTypeParameterInstantiation();
  }
}

function flowParseTypeofType() {
  (0, _util.expect)(_types.TokenType._typeof);
  flowParsePrimaryType();
}

function flowParseTupleType() {
  (0, _util.expect)(_types.TokenType.bracketL);
  // We allow trailing commas
  while (_base.state.pos < _base.input.length && !(0, _index.match)(_types.TokenType.bracketR)) {
    flowParseType();
    if ((0, _index.match)(_types.TokenType.bracketR)) {
      break;
    }
    (0, _util.expect)(_types.TokenType.comma);
  }
  (0, _util.expect)(_types.TokenType.bracketR);
}

function flowParseFunctionTypeParam() {
  const lookahead = (0, _index.lookaheadType)();
  if (lookahead === _types.TokenType.colon || lookahead === _types.TokenType.question) {
    (0, _expression.parseIdentifier)();
    (0, _index.eat)(_types.TokenType.question);
    flowParseTypeInitialiser();
  } else {
    flowParseType();
  }
}

function flowParseFunctionTypeParams() {
  while (!(0, _index.match)(_types.TokenType.parenR) && !(0, _index.match)(_types.TokenType.ellipsis)) {
    flowParseFunctionTypeParam();
    if (!(0, _index.match)(_types.TokenType.parenR)) {
      (0, _util.expect)(_types.TokenType.comma);
    }
  }
  if ((0, _index.eat)(_types.TokenType.ellipsis)) {
    flowParseFunctionTypeParam();
  }
}

// The parsing of types roughly parallels the parsing of expressions, and
// primary types are kind of like primary expressions...they're the
// primitives with which other types are constructed.
function flowParsePrimaryType() {
  let isGroupedType = false;
  const oldNoAnonFunctionType = _base.state.noAnonFunctionType;

  switch (_base.state.type) {
    case _types.TokenType.name: {
      (0, _expression.parseIdentifier)();
      flowParseGenericType();
      return;
    }

    case _types.TokenType.braceL:
      flowParseObjectType(false, false);
      return;

    case _types.TokenType.braceBarL:
      flowParseObjectType(false, true);
      return;

    case _types.TokenType.bracketL:
      flowParseTupleType();
      return;

    case _types.TokenType.lessThan:
      flowParseTypeParameterDeclaration();
      (0, _util.expect)(_types.TokenType.parenL);
      flowParseFunctionTypeParams();
      (0, _util.expect)(_types.TokenType.parenR);
      (0, _util.expect)(_types.TokenType.arrow);
      flowParseType();
      return;

    case _types.TokenType.parenL:
      (0, _index.next)();

      // Check to see if this is actually a grouped type
      if (!(0, _index.match)(_types.TokenType.parenR) && !(0, _index.match)(_types.TokenType.ellipsis)) {
        if ((0, _index.match)(_types.TokenType.name)) {
          const token = (0, _index.lookaheadType)();
          isGroupedType = token !== _types.TokenType.question && token !== _types.TokenType.colon;
        } else {
          isGroupedType = true;
        }
      }

      if (isGroupedType) {
        _base.state.noAnonFunctionType = false;
        flowParseType();
        _base.state.noAnonFunctionType = oldNoAnonFunctionType;

        // A `,` or a `) =>` means this is an anonymous function type
        if (
          _base.state.noAnonFunctionType ||
          !((0, _index.match)(_types.TokenType.comma) || ((0, _index.match)(_types.TokenType.parenR) && (0, _index.lookaheadType)() === _types.TokenType.arrow))
        ) {
          (0, _util.expect)(_types.TokenType.parenR);
          return;
        } else {
          // Eat a comma if there is one
          (0, _index.eat)(_types.TokenType.comma);
        }
      }

      flowParseFunctionTypeParams();

      (0, _util.expect)(_types.TokenType.parenR);
      (0, _util.expect)(_types.TokenType.arrow);
      flowParseType();
      return;

    case _types.TokenType.minus:
      (0, _index.next)();
      (0, _expression.parseLiteral)();
      return;

    case _types.TokenType.string:
    case _types.TokenType.num:
    case _types.TokenType._true:
    case _types.TokenType._false:
    case _types.TokenType._null:
    case _types.TokenType._this:
    case _types.TokenType._void:
    case _types.TokenType.star:
      (0, _index.next)();
      return;

    default:
      if (_base.state.type === _types.TokenType._typeof) {
        flowParseTypeofType();
        return;
      }
  }

  throw (0, _util.unexpected)();
}

function flowParsePostfixType() {
  flowParsePrimaryType();
  while (!(0, _util.canInsertSemicolon)() && (0, _index.match)(_types.TokenType.bracketL)) {
    (0, _util.expect)(_types.TokenType.bracketL);
    (0, _util.expect)(_types.TokenType.bracketR);
  }
}

function flowParsePrefixType() {
  if ((0, _index.eat)(_types.TokenType.question)) {
    flowParsePrefixType();
  } else {
    flowParsePostfixType();
  }
}

function flowParseAnonFunctionWithoutParens() {
  flowParsePrefixType();
  if (!_base.state.noAnonFunctionType && (0, _index.eat)(_types.TokenType.arrow)) {
    flowParseType();
  }
}

function flowParseIntersectionType() {
  (0, _index.eat)(_types.TokenType.bitwiseAND);
  flowParseAnonFunctionWithoutParens();
  while ((0, _index.eat)(_types.TokenType.bitwiseAND)) {
    flowParseAnonFunctionWithoutParens();
  }
}

function flowParseUnionType() {
  (0, _index.eat)(_types.TokenType.bitwiseOR);
  flowParseIntersectionType();
  while ((0, _index.eat)(_types.TokenType.bitwiseOR)) {
    flowParseIntersectionType();
  }
}

function flowParseType() {
  flowParseUnionType();
}

 function flowParseTypeAnnotation() {
  flowParseTypeInitialiser();
} exports.flowParseTypeAnnotation = flowParseTypeAnnotation;

function flowParseTypeAnnotatableIdentifier() {
  (0, _expression.parseIdentifier)();
  if ((0, _index.match)(_types.TokenType.colon)) {
    flowParseTypeAnnotation();
  }
}

 function flowParseVariance() {
  if ((0, _index.match)(_types.TokenType.plus) || (0, _index.match)(_types.TokenType.minus)) {
    (0, _index.next)();
  }
} exports.flowParseVariance = flowParseVariance;

// ==================================
// Overrides
// ==================================

 function flowParseFunctionBodyAndFinish(
  functionStart,
  isGenerator,
  allowExpressionBody = null,
  funcContextId,
) {
  // For arrow functions, `parseArrow` handles the return type itself.
  if (!allowExpressionBody && (0, _index.match)(_types.TokenType.colon)) {
    flowParseTypeAndPredicateInitialiser();
  }

  (0, _expression.parseFunctionBody)(functionStart, isGenerator, allowExpressionBody, funcContextId);
} exports.flowParseFunctionBodyAndFinish = flowParseFunctionBodyAndFinish;

// interfaces
 function flowTryParseStatement() {
  if ((0, _index.match)(_types.TokenType.name) && _base.state.contextualKeyword === _index.ContextualKeyword._interface) {
    const oldIsType = (0, _index.pushTypeContext)(0);
    (0, _index.next)();
    flowParseInterface();
    (0, _index.popTypeContext)(oldIsType);
    return true;
  } else {
    return false;
  }
} exports.flowTryParseStatement = flowTryParseStatement;

// declares, interfaces and type aliases
 function flowParseIdentifierStatement(contextualKeyword) {
  if (contextualKeyword === _index.ContextualKeyword._declare) {
    if (
      (0, _index.match)(_types.TokenType._class) ||
      (0, _index.match)(_types.TokenType.name) ||
      (0, _index.match)(_types.TokenType._function) ||
      (0, _index.match)(_types.TokenType._var) ||
      (0, _index.match)(_types.TokenType._export)
    ) {
      const oldIsType = (0, _index.pushTypeContext)(1);
      flowParseDeclare();
      (0, _index.popTypeContext)(oldIsType);
    }
  } else if ((0, _index.match)(_types.TokenType.name)) {
    if (contextualKeyword === _index.ContextualKeyword._interface) {
      const oldIsType = (0, _index.pushTypeContext)(1);
      flowParseInterface();
      (0, _index.popTypeContext)(oldIsType);
    } else if (contextualKeyword === _index.ContextualKeyword._type) {
      const oldIsType = (0, _index.pushTypeContext)(1);
      flowParseTypeAlias();
      (0, _index.popTypeContext)(oldIsType);
    } else if (contextualKeyword === _index.ContextualKeyword._opaque) {
      const oldIsType = (0, _index.pushTypeContext)(1);
      flowParseOpaqueType(false);
      (0, _index.popTypeContext)(oldIsType);
    }
  }
  (0, _util.semicolon)();
} exports.flowParseIdentifierStatement = flowParseIdentifierStatement;

// export type
 function flowShouldParseExportDeclaration() {
  return (
    (0, _util.isContextual)(_index.ContextualKeyword._type) ||
    (0, _util.isContextual)(_index.ContextualKeyword._interface) ||
    (0, _util.isContextual)(_index.ContextualKeyword._opaque)
  );
} exports.flowShouldParseExportDeclaration = flowShouldParseExportDeclaration;

 function flowShouldDisallowExportDefaultSpecifier() {
  return (
    (0, _index.match)(_types.TokenType.name) &&
    (_base.state.contextualKeyword === _index.ContextualKeyword._type ||
      _base.state.contextualKeyword === _index.ContextualKeyword._interface ||
      _base.state.contextualKeyword === _index.ContextualKeyword._opaque)
  );
} exports.flowShouldDisallowExportDefaultSpecifier = flowShouldDisallowExportDefaultSpecifier;

 function flowParseExportDeclaration() {
  if ((0, _util.isContextual)(_index.ContextualKeyword._type)) {
    const oldIsType = (0, _index.pushTypeContext)(1);
    (0, _index.next)();

    if ((0, _index.match)(_types.TokenType.braceL)) {
      // export type { foo, bar };
      (0, _statement.parseExportSpecifiers)();
      (0, _statement.parseExportFrom)();
    } else {
      // export type Foo = Bar;
      flowParseTypeAlias();
    }
    (0, _index.popTypeContext)(oldIsType);
  } else if ((0, _util.isContextual)(_index.ContextualKeyword._opaque)) {
    const oldIsType = (0, _index.pushTypeContext)(1);
    (0, _index.next)();
    // export opaque type Foo = Bar;
    flowParseOpaqueType(false);
    (0, _index.popTypeContext)(oldIsType);
  } else if ((0, _util.isContextual)(_index.ContextualKeyword._interface)) {
    const oldIsType = (0, _index.pushTypeContext)(1);
    (0, _index.next)();
    flowParseInterface();
    (0, _index.popTypeContext)(oldIsType);
  } else {
    (0, _statement.parseStatement)(true);
  }
} exports.flowParseExportDeclaration = flowParseExportDeclaration;

 function flowShouldParseExportStar() {
  return (0, _index.match)(_types.TokenType.star) || ((0, _util.isContextual)(_index.ContextualKeyword._type) && (0, _index.lookaheadType)() === _types.TokenType.star);
} exports.flowShouldParseExportStar = flowShouldParseExportStar;

 function flowParseExportStar() {
  if ((0, _util.eatContextual)(_index.ContextualKeyword._type)) {
    const oldIsType = (0, _index.pushTypeContext)(2);
    (0, _statement.baseParseExportStar)();
    (0, _index.popTypeContext)(oldIsType);
  } else {
    (0, _statement.baseParseExportStar)();
  }
} exports.flowParseExportStar = flowParseExportStar;

// parse a the super class type parameters and implements
 function flowAfterParseClassSuper(hasSuper) {
  if (hasSuper && (0, _index.match)(_types.TokenType.lessThan)) {
    flowParseTypeParameterInstantiation();
  }
  if ((0, _util.isContextual)(_index.ContextualKeyword._implements)) {
    _base.state.tokens[_base.state.tokens.length - 1].type = _types.TokenType._implements;
    const oldIsType = (0, _index.pushTypeContext)(0);
    (0, _index.next)();
    do {
      flowParseRestrictedIdentifier();
      if ((0, _index.match)(_types.TokenType.lessThan)) {
        flowParseTypeParameterInstantiation();
      }
    } while ((0, _index.eat)(_types.TokenType.comma));
    (0, _index.popTypeContext)(oldIsType);
  }
} exports.flowAfterParseClassSuper = flowAfterParseClassSuper;

// parse type parameters for object method shorthand
 function flowStartParseObjPropValue() {
  // method shorthand
  if ((0, _index.match)(_types.TokenType.lessThan)) {
    flowParseTypeParameterDeclaration();
    if (!(0, _index.match)(_types.TokenType.parenL)) (0, _util.unexpected)();
  }
} exports.flowStartParseObjPropValue = flowStartParseObjPropValue;

 function flowParseAssignableListItemTypes() {
  const oldIsType = (0, _index.pushTypeContext)(0);
  (0, _index.eat)(_types.TokenType.question);
  if ((0, _index.match)(_types.TokenType.colon)) {
    flowParseTypeAnnotation();
  }
  (0, _index.popTypeContext)(oldIsType);
} exports.flowParseAssignableListItemTypes = flowParseAssignableListItemTypes;

// parse typeof and type imports
 function flowStartParseImportSpecifiers() {
  let kind = null;
  if ((0, _index.match)(_types.TokenType._typeof)) {
    kind = "typeof";
  } else if ((0, _util.isContextual)(_index.ContextualKeyword._type)) {
    kind = "type";
  }
  if (kind) {
    const lh = (0, _index.lookaheadTypeAndKeyword)();
    if (isMaybeDefaultImport(lh) || lh.type === _types.TokenType.braceL || lh.type === _types.TokenType.star) {
      (0, _index.next)();
    }
  }
} exports.flowStartParseImportSpecifiers = flowStartParseImportSpecifiers;

// parse import-type/typeof shorthand
 function flowParseImportSpecifier() {
  const isTypeKeyword =
    _base.state.contextualKeyword === _index.ContextualKeyword._type || _base.state.type === _types.TokenType._typeof;
  if (isTypeKeyword) {
    (0, _index.next)();
  } else {
    (0, _expression.parseIdentifier)();
  }

  if ((0, _util.isContextual)(_index.ContextualKeyword._as) && !(0, _util.isLookaheadContextual)(_index.ContextualKeyword._as)) {
    (0, _expression.parseIdentifier)();
    if (isTypeKeyword && !(0, _index.match)(_types.TokenType.name) && !(_base.state.type & _types.TokenType.IS_KEYWORD)) {
      // `import {type as ,` or `import {type as }`
    } else {
      // `import {type as foo`
      (0, _expression.parseIdentifier)();
    }
  } else if (isTypeKeyword && ((0, _index.match)(_types.TokenType.name) || !!(_base.state.type & _types.TokenType.IS_KEYWORD))) {
    // `import {type foo`
    (0, _expression.parseIdentifier)();
    if ((0, _util.eatContextual)(_index.ContextualKeyword._as)) {
      (0, _expression.parseIdentifier)();
    }
  }
} exports.flowParseImportSpecifier = flowParseImportSpecifier;

// parse function type parameters - function foo<T>() {}
 function flowStartParseFunctionParams() {
  // Originally this checked if the method is a getter/setter, but if it was, we'd crash soon
  // anyway, so don't try to propagate that information.
  if ((0, _index.match)(_types.TokenType.lessThan)) {
    const oldIsType = (0, _index.pushTypeContext)(0);
    flowParseTypeParameterDeclaration();
    (0, _index.popTypeContext)(oldIsType);
  }
} exports.flowStartParseFunctionParams = flowStartParseFunctionParams;

// parse flow type annotations on variable declarator heads - let foo: string = bar
 function flowAfterParseVarHead() {
  if ((0, _index.match)(_types.TokenType.colon)) {
    flowParseTypeAnnotation();
  }
} exports.flowAfterParseVarHead = flowAfterParseVarHead;

// parse the return type of an async arrow function - let foo = (async (): number => {});
 function flowStartParseAsyncArrowFromCallExpression() {
  if ((0, _index.match)(_types.TokenType.colon)) {
    const oldNoAnonFunctionType = _base.state.noAnonFunctionType;
    _base.state.noAnonFunctionType = true;
    flowParseTypeAnnotation();
    _base.state.noAnonFunctionType = oldNoAnonFunctionType;
  }
} exports.flowStartParseAsyncArrowFromCallExpression = flowStartParseAsyncArrowFromCallExpression;

// We need to support type parameter declarations for arrow functions. This
// is tricky. There are three situations we need to handle
//
// 1. This is either JSX or an arrow function. We'll try JSX first. If that
//    fails, we'll try an arrow function. If that fails, we'll throw the JSX
//    error.
// 2. This is an arrow function. We'll parse the type parameter declaration,
//    parse the rest, make sure the rest is an arrow function, and go from
//    there
// 3. This is neither. Just call the super method
 function flowParseMaybeAssign(noIn, afterLeftParse) {
  let jsxError = null;
  if ((0, _index.match)(_types.TokenType.lessThan)) {
    const snapshot = _base.state.snapshot();
    try {
      return (0, _expression.baseParseMaybeAssign)(noIn, afterLeftParse);
    } catch (err) {
      if (err instanceof SyntaxError) {
        _base.state.restoreFromSnapshot(snapshot);
        _base.state.type = _types.TokenType.typeParameterStart;
        jsxError = err;
      } else {
        // istanbul ignore next: no such error is expected
        throw err;
      }
    }
  }

  if (jsxError != null || (0, _index.match)(_types.TokenType.lessThan)) {
    let wasArrow = false;
    try {
      const oldIsType = (0, _index.pushTypeContext)(0);
      flowParseTypeParameterDeclaration();
      (0, _index.popTypeContext)(oldIsType);
      wasArrow = (0, _expression.baseParseMaybeAssign)(noIn, afterLeftParse);
    } catch (err) {
      throw jsxError || err;
    }

    if (wasArrow) {
      return true;
    }
    (0, _util.unexpected)();
  }

  return (0, _expression.baseParseMaybeAssign)(noIn, afterLeftParse);
} exports.flowParseMaybeAssign = flowParseMaybeAssign;

// handle return types for arrow functions
 function flowParseArrow() {
  if ((0, _index.match)(_types.TokenType.colon)) {
    const oldIsType = (0, _index.pushTypeContext)(0);
    const snapshot = _base.state.snapshot();
    try {
      const oldNoAnonFunctionType = _base.state.noAnonFunctionType;
      _base.state.noAnonFunctionType = true;
      flowParseTypeAndPredicateInitialiser();
      _base.state.noAnonFunctionType = oldNoAnonFunctionType;

      if ((0, _util.canInsertSemicolon)()) (0, _util.unexpected)();
      if (!(0, _index.match)(_types.TokenType.arrow)) (0, _util.unexpected)();
    } catch (err) {
      if (err instanceof SyntaxError) {
        _base.state.restoreFromSnapshot(snapshot);
      } else {
        // istanbul ignore next: no such error is expected
        throw err;
      }
    }
    (0, _index.popTypeContext)(oldIsType);
  }
  return (0, _index.eat)(_types.TokenType.arrow);
} exports.flowParseArrow = flowParseArrow;

 function flowParseSubscripts(startPos, noCalls) {
  if (
    _base.state.tokens[_base.state.tokens.length - 1].contextualKeyword === _index.ContextualKeyword._async &&
    (0, _index.match)(_types.TokenType.lessThan)
  ) {
    const snapshot = _base.state.snapshot();
    let error;
    try {
      const wasArrow = parseAsyncArrowWithTypeParameters(startPos);
      if (wasArrow) {
        return;
      }
    } catch (e) {
      error = e;
    }

    _base.state.restoreFromSnapshot(snapshot);
    try {
      (0, _expression.baseParseSubscripts)(startPos, noCalls);
      return;
    } catch (e) {
      throw error || e;
    }
  }

  (0, _expression.baseParseSubscripts)(startPos, noCalls);
} exports.flowParseSubscripts = flowParseSubscripts;

// Returns true if there was an arrow function here.
function parseAsyncArrowWithTypeParameters(startPos) {
  const startTokenIndex = _base.state.tokens.length;
  (0, _statement.parseFunctionParams)();
  if (!(0, _expression.parseArrow)()) {
    return false;
  }
  (0, _expression.parseArrowExpression)(startPos, startTokenIndex);
  return true;
}
