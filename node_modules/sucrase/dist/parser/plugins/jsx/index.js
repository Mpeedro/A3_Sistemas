"use strict"; function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } } function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }Object.defineProperty(exports, "__esModule", {value: true});









var _index = require('../../tokenizer/index');
var _types = require('../../tokenizer/types');
var _base = require('../../traverser/base');
var _expression = require('../../traverser/expression');
var _util = require('../../traverser/util');
var _charcodes = require('../../util/charcodes');
var _identifier = require('../../util/identifier');

// Reads inline JSX contents token.
function jsxReadToken() {
  for (;;) {
    if (_base.state.pos >= _base.input.length) {
      (0, _base.raise)(_base.state.start, "Unterminated JSX contents");
    }

    const ch = _base.input.charCodeAt(_base.state.pos);

    switch (ch) {
      case _charcodes.charCodes.lessThan:
      case _charcodes.charCodes.leftCurlyBrace:
        if (_base.state.pos === _base.state.start) {
          if (ch === _charcodes.charCodes.lessThan) {
            _base.state.pos++;
            (0, _index.finishToken)(_types.TokenType.jsxTagStart);
            return;
          }
          (0, _index.getTokenFromCode)(ch);
          return;
        }
        (0, _index.finishToken)(_types.TokenType.jsxText);
        return;

      default:
        _base.state.pos++;
    }
  }
}

function jsxReadString(quote) {
  _base.state.pos++;
  for (;;) {
    if (_base.state.pos >= _base.input.length) {
      (0, _base.raise)(_base.state.start, "Unterminated string constant");
    }

    const ch = _base.input.charCodeAt(_base.state.pos);
    if (ch === quote) {
      _base.state.pos++;
      break;
    }
    _base.state.pos++;
  }
  (0, _index.finishToken)(_types.TokenType.string);
}

// Read a JSX identifier (valid tag or attribute name).
//
// Optimized version since JSX identifiers can't contain
// escape characters and so can be read as single slice.
// Also assumes that first character was already checked
// by isIdentifierStart in readToken.

function jsxReadWord() {
  let ch;
  do {
    ch = _base.input.charCodeAt(++_base.state.pos);
  } while ((0, _identifier.isIdentifierChar)(ch) || ch === _charcodes.charCodes.dash);
  (0, _index.finishToken)(_types.TokenType.jsxName);
}

// Parse next token as JSX identifier
function jsxParseIdentifier() {
  nextJSXTagToken();
}

// Parse namespaced identifier.
function jsxParseNamespacedName(identifierRole) {
  jsxParseIdentifier();
  if (!(0, _index.eat)(_types.TokenType.colon)) {
    // Plain identifier, so this is an access.
    _base.state.tokens[_base.state.tokens.length - 1].identifierRole = identifierRole;
    return;
  }
  // Process the second half of the namespaced name.
  jsxParseIdentifier();
}

// Parses element name in any form - namespaced, member
// or single identifier.
function jsxParseElementName() {
  jsxParseNamespacedName(_index.IdentifierRole.Access);
  while ((0, _index.match)(_types.TokenType.dot)) {
    nextJSXTagToken();
    jsxParseIdentifier();
  }
}

// Parses any type of JSX attribute value.
function jsxParseAttributeValue() {
  switch (_base.state.type) {
    case _types.TokenType.braceL:
      jsxParseExpressionContainer();
      nextJSXTagToken();
      return;

    case _types.TokenType.jsxTagStart:
      jsxParseElement();
      nextJSXTagToken();
      return;

    case _types.TokenType.string:
      nextJSXTagToken();
      return;

    default:
      throw (0, _base.raise)(_base.state.start, "JSX value should be either an expression or a quoted JSX text");
  }
}

function jsxParseEmptyExpression() {
  // Do nothing.
}

// Parse JSX spread child
function jsxParseSpreadChild() {
  (0, _util.expect)(_types.TokenType.braceL);
  (0, _util.expect)(_types.TokenType.ellipsis);
  (0, _expression.parseExpression)();
  (0, _util.expect)(_types.TokenType.braceR);
}

// Parses JSX expression enclosed into curly brackets.
// Does not parse the last token.
function jsxParseExpressionContainer() {
  (0, _index.next)();
  if ((0, _index.match)(_types.TokenType.braceR)) {
    jsxParseEmptyExpression();
  } else {
    (0, _expression.parseExpression)();
  }
}

// Parses following JSX attribute name-value pair.
function jsxParseAttribute() {
  if ((0, _index.eat)(_types.TokenType.braceL)) {
    (0, _util.expect)(_types.TokenType.ellipsis);
    (0, _expression.parseMaybeAssign)();
    // }
    nextJSXTagToken();
    return;
  }
  jsxParseNamespacedName(_index.IdentifierRole.ObjectKey);
  if ((0, _index.match)(_types.TokenType.eq)) {
    nextJSXTagToken();
    jsxParseAttributeValue();
  }
}

// Parses JSX opening tag starting after "<".
// Returns true if the tag was self-closing.
// Does not parse the last token.
function jsxParseOpeningElement() {
  if ((0, _index.match)(_types.TokenType.jsxTagEnd)) {
    nextJSXExprToken();
    // This is an open-fragment.
    return false;
  }
  jsxParseElementName();
  while (!(0, _index.match)(_types.TokenType.slash) && !(0, _index.match)(_types.TokenType.jsxTagEnd)) {
    jsxParseAttribute();
  }
  const isSelfClosing = (0, _index.match)(_types.TokenType.slash);
  if (isSelfClosing) {
    // /
    nextJSXTagToken();
  }
  return isSelfClosing;
}

// Parses JSX closing tag starting after "</".
// Does not parse the last token.
function jsxParseClosingElement() {
  if ((0, _index.match)(_types.TokenType.jsxTagEnd)) {
    // Fragment syntax, so we immediately have a tag end.
    return;
  }
  jsxParseElementName();
}

// Parses entire JSX element, including its opening tag
// (starting after "<"), attributes, contents and closing tag.
// Does not parse the last token.
function jsxParseElementAt() {
  const isSelfClosing = jsxParseOpeningElement();
  if (!isSelfClosing) {
    nextJSXExprToken();
    while (true) {
      switch (_base.state.type) {
        case _types.TokenType.jsxTagStart:
          nextJSXTagToken();
          if ((0, _index.match)(_types.TokenType.slash)) {
            nextJSXTagToken();
            jsxParseClosingElement();
            return;
          }
          jsxParseElementAt();
          nextJSXExprToken();
          break;

        case _types.TokenType.jsxText:
          nextJSXExprToken();
          break;

        case _types.TokenType.braceL:
          if ((0, _index.lookaheadType)() === _types.TokenType.ellipsis) {
            jsxParseSpreadChild();
          } else {
            jsxParseExpressionContainer();
            nextJSXExprToken();
          }

          break;

        // istanbul ignore next - should never happen
        default:
          throw (0, _util.unexpected)();
      }
    }
  }
}

// Parses entire JSX element from current position.
// Does not parse the last token.
 function jsxParseElement() {
  nextJSXTagToken();
  jsxParseElementAt();
} exports.jsxParseElement = jsxParseElement;

// ==================================
// Overrides
// ==================================

function nextJSXTagToken() {
  _base.state.tokens.push(new (0, _index.Token)());
  (0, _index.skipSpace)();
  _base.state.start = _base.state.pos;
  const code = _base.input.charCodeAt(_base.state.pos);

  if ((0, _identifier.isIdentifierStart)(code)) {
    jsxReadWord();
  } else if (code === _charcodes.charCodes.quotationMark || code === _charcodes.charCodes.apostrophe) {
    jsxReadString(code);
  } else {
    // The following tokens are just one character each.
    ++_base.state.pos;
    switch (code) {
      case _charcodes.charCodes.greaterThan:
        (0, _index.finishToken)(_types.TokenType.jsxTagEnd);
        break;
      case _charcodes.charCodes.slash:
        (0, _index.finishToken)(_types.TokenType.slash);
        break;
      case _charcodes.charCodes.equalsTo:
        (0, _index.finishToken)(_types.TokenType.eq);
        break;
      case _charcodes.charCodes.leftCurlyBrace:
        (0, _index.finishToken)(_types.TokenType.braceL);
        break;
      case _charcodes.charCodes.dot:
        (0, _index.finishToken)(_types.TokenType.dot);
        break;
      case _charcodes.charCodes.colon:
        (0, _index.finishToken)(_types.TokenType.colon);
        break;
      default:
        (0, _util.unexpected)();
    }
  }
}

function nextJSXExprToken() {
  _base.state.tokens.push(new (0, _index.Token)());
  _base.state.start = _base.state.pos;
  jsxReadToken();
}
