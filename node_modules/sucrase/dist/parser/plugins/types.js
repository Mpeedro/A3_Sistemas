"use strict"; function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } } function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }Object.defineProperty(exports, "__esModule", {value: true});var _index = require('../tokenizer/index');
var _types = require('../tokenizer/types');
var _base = require('../traverser/base');
var _expression = require('../traverser/expression');
var _flow = require('./flow');
var _typescript = require('./typescript');

/**
 * Common parser code for TypeScript and Flow.
 */

// An apparent conditional expression could actually be an optional parameter in an arrow function.
 function typedParseConditional(noIn, startPos) {
  // only do the expensive clone if there is a question mark
  // and if we come from inside parens
  if (!(0, _index.match)(_types.TokenType.question)) {
    (0, _expression.baseParseConditional)(noIn, startPos);
    return;
  }

  const snapshot = _base.state.snapshot();
  try {
    (0, _expression.baseParseConditional)(noIn, startPos);
    return;
  } catch (err) {
    if (!(err instanceof SyntaxError)) {
      // istanbul ignore next: no such error is expected
      throw err;
    }
    _base.state.restoreFromSnapshot(snapshot);
  }
} exports.typedParseConditional = typedParseConditional;

// Note: These "type casts" are *not* valid TS expressions.
// But we parse them here and change them when completing the arrow function.
 function typedParseParenItem() {
  if ((0, _index.eat)(_types.TokenType.question)) {
    _base.state.tokens[_base.state.tokens.length - 1].isType = true;
  }
  if ((0, _index.match)(_types.TokenType.colon)) {
    if (_base.isTypeScriptEnabled) {
      (0, _typescript.tsParseTypeAnnotation)();
    } else if (_base.isFlowEnabled) {
      (0, _flow.flowParseTypeAnnotation)();
    }
  }
} exports.typedParseParenItem = typedParseParenItem;
