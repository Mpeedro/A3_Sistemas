"use strict"; function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } } function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }Object.defineProperty(exports, "__esModule", {value: true});
var _types = require('./types');

 class Scope {
  
  
  

  constructor(startTokenIndex, endTokenIndex, isFunctionScope) {
    this.startTokenIndex = startTokenIndex;
    this.endTokenIndex = endTokenIndex;
    this.isFunctionScope = isFunctionScope;
  }
} exports.Scope = Scope;

 class StateSnapshot {
  
  
  
  
  
  
  
  
  
  

  constructor(
    potentialArrowAt,
    noAnonFunctionType,
    tokensLength,
    scopesLength,
    pos,
    type,
    contextualKeyword,
    start,
    end,
    isType,
  ) {
    this.potentialArrowAt = potentialArrowAt;
    this.noAnonFunctionType = noAnonFunctionType;
    this.tokensLength = tokensLength;
    this.scopesLength = scopesLength;
    this.pos = pos;
    this.type = type;
    this.contextualKeyword = contextualKeyword;
    this.start = start;
    this.end = end;
    this.isType = isType;
  }
} exports.StateSnapshot = StateSnapshot;

 class State {
  init() {
    this.potentialArrowAt = -1;
    this.noAnonFunctionType = false;
    this.tokens = [];
    this.scopes = [];
    this.pos = 0;
    this.type = _types.TokenType.eof;
    this.start = this.pos;
    this.end = this.pos;

    this.isType = false;
  }

  // Used to signify the start of a potential arrow function
  

  // Used by Flow to handle an edge case involving function type parsing.
  

  // Token store.
  

  // Array of all observed scopes, ordered by their ending position.
  

  // The current position of the tokenizer in the input.
  

  // Information about the current token.
  
  
  
  

  

  snapshot() {
    return new StateSnapshot(
      this.potentialArrowAt,
      this.noAnonFunctionType,
      this.tokens.length,
      this.scopes.length,
      this.pos,
      this.type,
      this.contextualKeyword,
      this.start,
      this.end,
      this.isType,
    );
  }

  restoreFromSnapshot(snapshot) {
    this.potentialArrowAt = snapshot.potentialArrowAt;
    this.noAnonFunctionType = snapshot.noAnonFunctionType;
    this.tokens.length = snapshot.tokensLength;
    this.scopes.length = snapshot.scopesLength;
    this.pos = snapshot.pos;
    this.type = snapshot.type;
    this.contextualKeyword = snapshot.contextualKeyword;
    this.start = snapshot.start;
    this.end = snapshot.end;
    this.isType = snapshot.isType;
  }
} exports.default = State;
