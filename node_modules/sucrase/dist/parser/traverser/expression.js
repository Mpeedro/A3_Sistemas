"use strict"; function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } } function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }Object.defineProperty(exports, "__esModule", {value: true});/* eslint max-len: 0 */

// A recursive descent parser operates by defining functions for all
// syntactic elements, and recursively calling those, each function
// advancing the input stream and returning an AST node. Precedence
// of constructs (for example, the fact that `!x[1]` means `!(x[1])`
// instead of `(!x)[1]` is handled by the fact that the parser
// function that parses unary prefix operators is called first, and
// in turn calls the function that parses `[]` subscripts â€” that
// way, it'll receive the node for `x[1]` already parsed, and wraps
// *that* in the unary operator node.
//
// Acorn uses an [operator precedence parser][opp] to handle binary
// operator precedence, because it is much more compact than using
// the technique outlined above, which uses different, nesting
// functions to specify precedence, for all of the ten binary
// precedence levels that JavaScript defines.
//
// [opp]: http://en.wikipedia.org/wiki/Operator-precedence_parser









var _flow = require('../plugins/flow');
var _index = require('../plugins/jsx/index');
var _types = require('../plugins/types');










var _typescript = require('../plugins/typescript');











var _index3 = require('../tokenizer/index');
var _state = require('../tokenizer/state');
var _types3 = require('../tokenizer/types');







var _base = require('./base');
var _lval = require('./lval');






var _statement = require('./statement');







var _util = require('./util');

 class StopState {
  
  constructor(stop) {
    this.stop = stop;
  }
} exports.StopState = StopState;

// ### Expression parsing

// These nest, from the most general expression type at the top to
// 'atomic', nondivisible expression types at the bottom. Most of
// the functions will simply let the function (s) below them parse,
// and, *if* the syntactic construct they handle is present, wrap
// the AST node that the inner parser gave them in another node.

// Parse a full expression. The optional arguments are used to
// forbid the `in` operator (in for loops initialization expressions)
// and provide reference for storing '=' operator inside shorthand
// property assignment in contexts where both object expression
// and object pattern might appear (so it's possible to raise
// delayed syntax error at correct position).e
 function parseExpression(noIn) {
  parseMaybeAssign(noIn);
  if ((0, _index3.match)(_types3.TokenType.comma)) {
    while ((0, _index3.eat)(_types3.TokenType.comma)) {
      parseMaybeAssign(noIn);
    }
  }
} exports.parseExpression = parseExpression;

 function parseMaybeAssign(noIn = null, afterLeftParse) {
  if (_base.isTypeScriptEnabled) {
    return (0, _typescript.tsParseMaybeAssign)(noIn, afterLeftParse);
  } else if (_base.isFlowEnabled) {
    return (0, _flow.flowParseMaybeAssign)(noIn, afterLeftParse);
  } else {
    return baseParseMaybeAssign(noIn, afterLeftParse);
  }
} exports.parseMaybeAssign = parseMaybeAssign;

// Parse an assignment expression. This includes applications of
// operators like `+=`.
// Returns true if the expression was an arrow function.
 function baseParseMaybeAssign(
  noIn = null,
  afterLeftParse,
) {
  if ((0, _index3.match)(_types3.TokenType._yield)) {
    parseYield();
    if (afterLeftParse) {
      afterLeftParse();
    }
    return false;
  }

  if ((0, _index3.match)(_types3.TokenType.parenL) || (0, _index3.match)(_types3.TokenType.name) || (0, _index3.match)(_types3.TokenType._yield)) {
    _base.state.potentialArrowAt = _base.state.start;
  }

  const wasArrow = parseMaybeConditional(noIn);
  if (afterLeftParse) {
    afterLeftParse();
  }
  if (_base.state.type & _types3.TokenType.IS_ASSIGN) {
    (0, _index3.next)();
    parseMaybeAssign(noIn);
    return false;
  }
  return wasArrow;
} exports.baseParseMaybeAssign = baseParseMaybeAssign;

// Parse a ternary conditional (`?:`) operator.
// Returns true if the expression was an arrow function.
function parseMaybeConditional(noIn) {
  const startPos = _base.state.start;
  const wasArrow = parseExprOps(noIn);
  if (wasArrow) {
    return true;
  }
  parseConditional(noIn, startPos);
  return false;
}

function parseConditional(noIn, startPos) {
  if (_base.isTypeScriptEnabled || _base.isFlowEnabled) {
    (0, _types.typedParseConditional)(noIn, startPos);
  } else {
    baseParseConditional(noIn, startPos);
  }
}

 function baseParseConditional(noIn, startPos) {
  if ((0, _index3.eat)(_types3.TokenType.question)) {
    parseMaybeAssign();
    (0, _util.expect)(_types3.TokenType.colon);
    parseMaybeAssign(noIn);
  }
} exports.baseParseConditional = baseParseConditional;

// Start the precedence parser.
// Returns true if this was an arrow function
function parseExprOps(noIn) {
  const wasArrow = parseMaybeUnary();
  if (wasArrow) {
    return true;
  }
  parseExprOp(-1, noIn);
  return false;
}

// Parse binary operators with the operator precedence parsing
// algorithm. `left` is the left-hand side of the operator.
// `minPrec` provides context that allows the function to stop and
// defer further parser to one of its callers when it encounters an
// operator that has a lower precedence than the set it is parsing.
function parseExprOp(minPrec, noIn) {
  if (
    _base.isTypeScriptEnabled &&
    (_types3.TokenType._in & _types3.TokenType.PRECEDENCE_MASK) > minPrec &&
    !(0, _util.hasPrecedingLineBreak)() &&
    (0, _util.eatContextual)(_index3.ContextualKeyword._as)
  ) {
    _base.state.tokens[_base.state.tokens.length - 1].type = _types3.TokenType._as;
    const oldIsType = (0, _index3.pushTypeContext)(1);
    (0, _typescript.tsParseType)();
    (0, _index3.popTypeContext)(oldIsType);
    parseExprOp(minPrec, noIn);
    return;
  }

  const prec = _base.state.type & _types3.TokenType.PRECEDENCE_MASK;
  if (prec > 0 && (!noIn || !(0, _index3.match)(_types3.TokenType._in))) {
    if (prec > minPrec) {
      const op = _base.state.type;
      (0, _index3.next)();

      if (op === _types3.TokenType.pipeline) {
        // Support syntax such as 10 |> x => x + 1
        _base.state.potentialArrowAt = _base.state.start;
      }

      parseMaybeUnary();
      parseExprOp(op & _types3.TokenType.IS_RIGHT_ASSOCIATIVE ? prec - 1 : prec, noIn);
      parseExprOp(minPrec, noIn);
    }
  }
}

// Parse unary operators, both prefix and postfix.
// Returns true if this was an arrow function.
 function parseMaybeUnary() {
  if (_base.isTypeScriptEnabled && !_base.isJSXEnabled && (0, _index3.eat)(_types3.TokenType.lessThan)) {
    (0, _typescript.tsParseTypeAssertion)();
    return false;
  }

  if (_base.state.type & _types3.TokenType.IS_PREFIX) {
    (0, _index3.next)();
    parseMaybeUnary();
    return false;
  }

  const wasArrow = parseExprSubscripts();
  if (wasArrow) {
    return true;
  }
  while (_base.state.type & _types3.TokenType.IS_POSTFIX && !(0, _util.canInsertSemicolon)()) {
    (0, _index3.next)();
  }
  return false;
} exports.parseMaybeUnary = parseMaybeUnary;

// Parse call, dot, and `[]`-subscript expressions.
// Returns true if this was an arrow function.
 function parseExprSubscripts() {
  const startPos = _base.state.start;
  const wasArrow = parseExprAtom();
  if (wasArrow) {
    return true;
  }
  parseSubscripts(startPos);
  return false;
} exports.parseExprSubscripts = parseExprSubscripts;

function parseSubscripts(startPos, noCalls = null) {
  if (_base.isFlowEnabled) {
    (0, _flow.flowParseSubscripts)(startPos, noCalls);
  } else {
    baseParseSubscripts(startPos, noCalls);
  }
}

 function baseParseSubscripts(startPos, noCalls = null) {
  const stopState = new StopState(false);
  do {
    parseSubscript(startPos, noCalls, stopState);
  } while (!stopState.stop);
} exports.baseParseSubscripts = baseParseSubscripts;

function parseSubscript(startPos, noCalls, stopState) {
  if (_base.isTypeScriptEnabled) {
    (0, _typescript.tsParseSubscript)(startPos, noCalls, stopState);
  } else {
    baseParseSubscript(startPos, noCalls, stopState);
  }
}

/** Set 'state.stop = true' to indicate that we should stop parsing subscripts. */
 function baseParseSubscript(
  startPos,
  noCalls,
  stopState,
) {
  if (!noCalls && (0, _index3.eat)(_types3.TokenType.doubleColon)) {
    parseNoCallExpr();
    stopState.stop = true;
    parseSubscripts(startPos, noCalls);
  } else if ((0, _index3.match)(_types3.TokenType.questionDot)) {
    if (noCalls && (0, _index3.lookaheadType)() === _types3.TokenType.parenL) {
      stopState.stop = true;
      return;
    }
    (0, _index3.next)();

    if ((0, _index3.eat)(_types3.TokenType.bracketL)) {
      parseExpression();
      (0, _util.expect)(_types3.TokenType.bracketR);
    } else if ((0, _index3.eat)(_types3.TokenType.parenL)) {
      parseCallExpressionArguments(_types3.TokenType.parenR);
    } else {
      parseIdentifier();
    }
  } else if ((0, _index3.eat)(_types3.TokenType.dot)) {
    parseMaybePrivateName();
  } else if ((0, _index3.eat)(_types3.TokenType.bracketL)) {
    parseExpression();
    (0, _util.expect)(_types3.TokenType.bracketR);
  } else if (!noCalls && (0, _index3.match)(_types3.TokenType.parenL)) {
    const possibleAsync = atPossibleAsync();
    // We see "async", but it's possible it's a usage of the name "async". Parse as if it's a
    // function call, and if we see an arrow later, backtrack and re-parse as a parameter list.
    const snapshotForAsyncArrow = possibleAsync ? _base.state.snapshot() : null;
    const startTokenIndex = _base.state.tokens.length;
    (0, _index3.next)();

    const callContextId = (0, _base.getNextContextId)();

    _base.state.tokens[_base.state.tokens.length - 1].contextId = callContextId;
    parseCallExpressionArguments(_types3.TokenType.parenR);
    _base.state.tokens[_base.state.tokens.length - 1].contextId = callContextId;

    if (possibleAsync && shouldParseAsyncArrow()) {
      // We hit an arrow, so backtrack and start again parsing function parameters.
      _base.state.restoreFromSnapshot(snapshotForAsyncArrow);
      stopState.stop = true;

      (0, _statement.parseFunctionParams)();
      parseAsyncArrowFromCallExpression(startPos, startTokenIndex);
    }
  } else if ((0, _index3.match)(_types3.TokenType.backQuote)) {
    // Tagged template expression.
    parseTemplate();
  } else {
    stopState.stop = true;
  }
} exports.baseParseSubscript = baseParseSubscript;

 function atPossibleAsync() {
  // This was made less strict than the original version to avoid passing around nodes, but it
  // should be safe to have rare false positives here.
  return (
    _base.state.tokens[_base.state.tokens.length - 1].contextualKeyword === _index3.ContextualKeyword._async &&
    !(0, _util.canInsertSemicolon)()
  );
} exports.atPossibleAsync = atPossibleAsync;

 function parseCallExpressionArguments(close) {
  let first = true;
  while (!(0, _index3.eat)(close)) {
    if (first) {
      first = false;
    } else {
      (0, _util.expect)(_types3.TokenType.comma);
      if ((0, _index3.eat)(close)) break;
    }

    parseExprListItem(false);
  }
} exports.parseCallExpressionArguments = parseCallExpressionArguments;

function shouldParseAsyncArrow() {
  return (0, _index3.match)(_types3.TokenType.colon) || (0, _index3.match)(_types3.TokenType.arrow);
}

function parseAsyncArrowFromCallExpression(functionStart, startTokenIndex) {
  if (_base.isTypeScriptEnabled) {
    (0, _typescript.tsStartParseAsyncArrowFromCallExpression)();
  } else if (_base.isFlowEnabled) {
    (0, _flow.flowStartParseAsyncArrowFromCallExpression)();
  }
  (0, _util.expect)(_types3.TokenType.arrow);
  parseArrowExpression(functionStart, startTokenIndex);
}

// Parse a no-call expression (like argument of `new` or `::` operators).

function parseNoCallExpr() {
  const startPos = _base.state.start;
  parseExprAtom();
  parseSubscripts(startPos, true);
}

// Parse an atomic expression â€” either a single token that is an
// expression, an expression started by a keyword like `function` or
// `new`, or an expression wrapped in punctuation like `()`, `[]`,
// or `{}`.
// Returns true if the parsed expression was an arrow function.
 function parseExprAtom() {
  if ((0, _index3.match)(_types3.TokenType.jsxText)) {
    parseLiteral();
    return false;
  } else if ((0, _index3.match)(_types3.TokenType.lessThan) && _base.isJSXEnabled) {
    _base.state.type = _types3.TokenType.jsxTagStart;
    (0, _index.jsxParseElement)();
    (0, _index3.next)();
    return false;
  }

  const canBeArrow = _base.state.potentialArrowAt === _base.state.start;
  switch (_base.state.type) {
    case _types3.TokenType.slash:
    case _types3.TokenType.assign:
      (0, _index3.retokenizeSlashAsRegex)();
    // Fall through.

    case _types3.TokenType._super:
    case _types3.TokenType._this:
    case _types3.TokenType.regexp:
    case _types3.TokenType.num:
    case _types3.TokenType.bigint:
    case _types3.TokenType.string:
    case _types3.TokenType._null:
    case _types3.TokenType._true:
    case _types3.TokenType._false:
      (0, _index3.next)();
      return false;

    case _types3.TokenType._import:
      if ((0, _index3.lookaheadType)() === _types3.TokenType.dot) {
        parseImportMetaProperty();
        return false;
      }
      (0, _index3.next)();
      return false;

    case _types3.TokenType.name: {
      const startTokenIndex = _base.state.tokens.length;
      const functionStart = _base.state.start;
      const contextualKeyword = _base.state.contextualKeyword;
      parseIdentifier();
      if (contextualKeyword === _index3.ContextualKeyword._await) {
        parseAwait();
        return false;
      } else if (
        contextualKeyword === _index3.ContextualKeyword._async &&
        (0, _index3.match)(_types3.TokenType._function) &&
        !(0, _util.canInsertSemicolon)()
      ) {
        (0, _index3.next)();
        (0, _statement.parseFunction)(functionStart, false, false);
        return false;
      } else if (canBeArrow && contextualKeyword === _index3.ContextualKeyword._async && (0, _index3.match)(_types3.TokenType.name)) {
        parseIdentifier();
        (0, _util.expect)(_types3.TokenType.arrow);
        // let foo = bar => {};
        parseArrowExpression(functionStart, startTokenIndex);
        return true;
      }

      if (canBeArrow && !(0, _util.canInsertSemicolon)() && (0, _index3.eat)(_types3.TokenType.arrow)) {
        parseArrowExpression(functionStart, startTokenIndex);
        return true;
      }

      _base.state.tokens[_base.state.tokens.length - 1].identifierRole = _index3.IdentifierRole.Access;
      return false;
    }

    case _types3.TokenType._do: {
      (0, _index3.next)();
      (0, _statement.parseBlock)(false);
      return false;
    }

    case _types3.TokenType.parenL: {
      const wasArrow = parseParenAndDistinguishExpression(canBeArrow);
      return wasArrow;
    }

    case _types3.TokenType.bracketL:
      (0, _index3.next)();
      parseExprList(_types3.TokenType.bracketR, true);
      return false;

    case _types3.TokenType.braceL:
      parseObj(false, false);
      return false;

    case _types3.TokenType._function:
      parseFunctionExpression();
      return false;

    case _types3.TokenType.at:
      (0, _statement.parseDecorators)();
    // Fall through.

    case _types3.TokenType._class:
      (0, _statement.parseClass)(false);
      return false;

    case _types3.TokenType._new:
      parseNew();
      return false;

    case _types3.TokenType.backQuote:
      parseTemplate();
      return false;

    case _types3.TokenType.doubleColon: {
      (0, _index3.next)();
      parseNoCallExpr();
      return false;
    }

    default:
      throw (0, _util.unexpected)();
  }
} exports.parseExprAtom = parseExprAtom;

function parseMaybePrivateName() {
  (0, _index3.eat)(_types3.TokenType.hash);
  parseIdentifier();
}

function parseFunctionExpression() {
  const functionStart = _base.state.start;
  parseIdentifier();
  if ((0, _index3.eat)(_types3.TokenType.dot)) {
    // function.sent
    parseMetaProperty();
  }
  (0, _statement.parseFunction)(functionStart, false);
}

function parseMetaProperty() {
  parseIdentifier();
}

function parseImportMetaProperty() {
  parseIdentifier();
  (0, _util.expect)(_types3.TokenType.dot);
  // import.meta
  parseMetaProperty();
}

 function parseLiteral() {
  (0, _index3.next)();
} exports.parseLiteral = parseLiteral;

 function parseParenExpression() {
  (0, _util.expect)(_types3.TokenType.parenL);
  parseExpression();
  (0, _util.expect)(_types3.TokenType.parenR);
} exports.parseParenExpression = parseParenExpression;

// Returns true if this was an arrow expression.
function parseParenAndDistinguishExpression(canBeArrow) {
  // Assume this is a normal parenthesized expression, but if we see an arrow, we'll bail and
  // start over as a parameter list.
  const snapshot = _base.state.snapshot();

  const startTokenIndex = _base.state.tokens.length;
  (0, _util.expect)(_types3.TokenType.parenL);

  const exprList = [];
  let first = true;
  let spreadStart = 0;
  let optionalCommaStart = 0;

  while (!(0, _index3.match)(_types3.TokenType.parenR)) {
    if (first) {
      first = false;
    } else {
      (0, _util.expect)(_types3.TokenType.comma);
      if ((0, _index3.match)(_types3.TokenType.parenR)) {
        optionalCommaStart = _base.state.start;
        break;
      }
    }

    if ((0, _index3.match)(_types3.TokenType.ellipsis)) {
      spreadStart = _base.state.start;
      (0, _lval.parseRest)(false /* isBlockScope */);
      parseParenItem();

      if ((0, _index3.match)(_types3.TokenType.comma) && (0, _index3.lookaheadType)() === _types3.TokenType.parenR) {
        (0, _base.raise)(_base.state.start, "A trailing comma is not permitted after the rest element");
      }

      break;
    } else {
      exprList.push(parseMaybeAssign(false, parseParenItem));
    }
  }

  (0, _util.expect)(_types3.TokenType.parenR);

  if (canBeArrow && shouldParseArrow()) {
    const wasArrow = parseArrow();
    if (wasArrow) {
      // It was an arrow function this whole time, so start over and parse it as params so that we
      // get proper token annotations.
      _base.state.restoreFromSnapshot(snapshot);
      // We don't need to worry about functionStart for arrow functions, so just use something.
      const functionStart = _base.state.start;
      // Don't specify a context ID because arrow function don't need a context ID.
      (0, _statement.parseFunctionParams)();
      parseArrow();
      parseArrowExpression(functionStart, startTokenIndex);
      return true;
    }
  }

  if (optionalCommaStart) {
    (0, _util.unexpected)(optionalCommaStart);
  }
  if (spreadStart) {
    (0, _util.unexpected)(spreadStart);
  }
  return false;
}

function shouldParseArrow() {
  return (0, _index3.match)(_types3.TokenType.colon) || !(0, _util.canInsertSemicolon)();
}

// Returns whether there was an arrow token.
 function parseArrow() {
  if (_base.isTypeScriptEnabled) {
    return (0, _typescript.tsParseArrow)();
  } else if (_base.isFlowEnabled) {
    return (0, _flow.flowParseArrow)();
  } else {
    return (0, _index3.eat)(_types3.TokenType.arrow);
  }
} exports.parseArrow = parseArrow;

function parseParenItem() {
  if (_base.isTypeScriptEnabled || _base.isFlowEnabled) {
    (0, _types.typedParseParenItem)();
  }
}

// New's precedence is slightly tricky. It must allow its argument to
// be a `[]` or dot subscript expression, but not a call â€” at least,
// not without wrapping it in parentheses. Thus, it uses the noCalls
// argument to parseSubscripts to prevent it from consuming the
// argument list.
function parseNew() {
  parseIdentifier();
  if ((0, _index3.eat)(_types3.TokenType.dot)) {
    // new.target
    parseMetaProperty();
    return;
  }
  parseNoCallExpr();
  (0, _index3.eat)(_types3.TokenType.questionDot);
  parseNewArguments();
}

function parseNewArguments() {
  if (_base.isTypeScriptEnabled) {
    (0, _typescript.tsStartParseNewArguments)();
  }
  if ((0, _index3.eat)(_types3.TokenType.parenL)) {
    parseExprList(_types3.TokenType.parenR);
  }
}

function parseTemplate() {
  // Finish `, read quasi
  (0, _index3.nextTemplateToken)();
  // Finish quasi, read ${
  (0, _index3.nextTemplateToken)();
  while (!(0, _index3.match)(_types3.TokenType.backQuote)) {
    (0, _util.expect)(_types3.TokenType.dollarBraceL);
    parseExpression();
    // Finish }, read quasi
    (0, _index3.nextTemplateToken)();
    // Finish quasi, read either ${ or `
    (0, _index3.nextTemplateToken)();
  }
  (0, _index3.next)();
}

// Parse an object literal or binding pattern.
 function parseObj(isPattern, isBlockScope) {
  // Attach a context ID to the object open and close brace and each object key.
  const contextId = (0, _base.getNextContextId)();
  let first = true;

  (0, _index3.next)();
  _base.state.tokens[_base.state.tokens.length - 1].contextId = contextId;

  let firstRestLocation = null;
  while (!(0, _index3.eat)(_types3.TokenType.braceR)) {
    if (first) {
      first = false;
    } else {
      (0, _util.expect)(_types3.TokenType.comma);
      if ((0, _index3.eat)(_types3.TokenType.braceR)) {
        break;
      }
    }

    let isGenerator = false;
    if ((0, _index3.match)(_types3.TokenType.ellipsis)) {
      // Note that this is labeled as an access on the token even though it might be an
      // assignment.
      (0, _lval.parseSpread)();
      if (isPattern) {
        const position = _base.state.start;
        if (firstRestLocation !== null) {
          (0, _util.unexpected)(firstRestLocation, "Cannot have multiple rest elements when destructuring");
        } else if ((0, _index3.eat)(_types3.TokenType.braceR)) {
          break;
        } else if ((0, _index3.match)(_types3.TokenType.comma) && (0, _index3.lookaheadType)() === _types3.TokenType.braceR) {
          (0, _util.unexpected)(position, "A trailing comma is not permitted after the rest element");
        } else {
          firstRestLocation = position;
          continue;
        }
      } else {
        continue;
      }
    }

    if (!isPattern) {
      isGenerator = (0, _index3.eat)(_types3.TokenType.star);
    }

    if (!isPattern && (0, _util.isContextual)(_index3.ContextualKeyword._async)) {
      if (isGenerator) (0, _util.unexpected)();

      parseIdentifier();
      if (
        (0, _index3.match)(_types3.TokenType.colon) ||
        (0, _index3.match)(_types3.TokenType.parenL) ||
        (0, _index3.match)(_types3.TokenType.braceR) ||
        (0, _index3.match)(_types3.TokenType.eq) ||
        (0, _index3.match)(_types3.TokenType.comma)
      ) {
        // This is a key called "async" rather than an async function.
      } else {
        if ((0, _index3.match)(_types3.TokenType.star)) {
          (0, _index3.next)();
          isGenerator = true;
        }
        parsePropertyName(contextId);
      }
    } else {
      parsePropertyName(contextId);
    }

    parseObjPropValue(isGenerator, isPattern, isBlockScope, contextId);
  }

  _base.state.tokens[_base.state.tokens.length - 1].contextId = contextId;
} exports.parseObj = parseObj;

function isGetterOrSetterMethod(isPattern) {
  // We go off of the next and don't bother checking if the node key is actually "get" or "set".
  // This lets us avoid generating a node, and should only make the validation worse.
  return (
    !isPattern &&
    ((0, _index3.match)(_types3.TokenType.string) || // get "string"() {}
    (0, _index3.match)(_types3.TokenType.num) || // get 1() {}
    (0, _index3.match)(_types3.TokenType.bracketL) || // get ["string"]() {}
    (0, _index3.match)(_types3.TokenType.name) || // get foo() {}
      !!(_base.state.type & _types3.TokenType.IS_KEYWORD)) // get debugger() {}
  );
}

// Returns true if this was a method.
function parseObjectMethod(
  isGenerator,
  isPattern,
  objectContextId,
) {
  // We don't need to worry about modifiers because object methods can't have optional bodies, so
  // the start will never be used.
  const functionStart = _base.state.start;
  if ((0, _index3.match)(_types3.TokenType.parenL)) {
    if (isPattern) (0, _util.unexpected)();
    parseMethod(functionStart, isGenerator, /* isConstructor */ false);
    return true;
  }

  if (isGetterOrSetterMethod(isPattern)) {
    parsePropertyName(objectContextId);
    parseMethod(functionStart, /* isGenerator */ false, /* isConstructor */ false);
    return true;
  }
  return false;
}

function parseObjectProperty(isPattern, isBlockScope) {
  if ((0, _index3.eat)(_types3.TokenType.colon)) {
    if (isPattern) {
      (0, _lval.parseMaybeDefault)(isBlockScope);
    } else {
      parseMaybeAssign(false);
    }
    return;
  }

  // Since there's no colon, we assume this is an object shorthand.

  // If we're in a destructuring, we've now discovered that the key was actually an assignee, so
  // we need to tag it as a declaration with the appropriate scope. Otherwise, we might need to
  // transform it on access, so mark it as an object shorthand.
  if (isPattern) {
    _base.state.tokens[_base.state.tokens.length - 1].identifierRole = isBlockScope
      ? _index3.IdentifierRole.BlockScopedDeclaration
      : _index3.IdentifierRole.FunctionScopedDeclaration;
  } else {
    _base.state.tokens[_base.state.tokens.length - 1].identifierRole = _index3.IdentifierRole.ObjectShorthand;
  }

  // Regardless of whether we know this to be a pattern or if we're in an ambiguous context, allow
  // parsing as if there's a default value.
  (0, _lval.parseMaybeDefault)(isBlockScope, true);
}

function parseObjPropValue(
  isGenerator,
  isPattern,
  isBlockScope,
  objectContextId,
) {
  if (_base.isTypeScriptEnabled) {
    (0, _typescript.tsStartParseObjPropValue)();
  } else if (_base.isFlowEnabled) {
    (0, _flow.flowStartParseObjPropValue)();
  }
  const wasMethod = parseObjectMethod(isGenerator, isPattern, objectContextId);
  if (!wasMethod) {
    parseObjectProperty(isPattern, isBlockScope);
  }
}

 function parsePropertyName(objectContextId) {
  if (_base.isFlowEnabled) {
    (0, _flow.flowParseVariance)();
  }
  if ((0, _index3.eat)(_types3.TokenType.bracketL)) {
    _base.state.tokens[_base.state.tokens.length - 1].contextId = objectContextId;
    parseMaybeAssign();
    (0, _util.expect)(_types3.TokenType.bracketR);
    _base.state.tokens[_base.state.tokens.length - 1].contextId = objectContextId;
  } else {
    if ((0, _index3.match)(_types3.TokenType.num) || (0, _index3.match)(_types3.TokenType.string)) {
      parseExprAtom();
    } else {
      parseMaybePrivateName();
    }

    _base.state.tokens[_base.state.tokens.length - 1].identifierRole = _index3.IdentifierRole.ObjectKey;
    _base.state.tokens[_base.state.tokens.length - 1].contextId = objectContextId;
  }
} exports.parsePropertyName = parsePropertyName;

// Parse object or class method.
 function parseMethod(
  functionStart,
  isGenerator,
  isConstructor,
) {
  const funcContextId = (0, _base.getNextContextId)();

  const startTokenIndex = _base.state.tokens.length;
  const allowModifiers = isConstructor; // For TypeScript parameter properties
  (0, _statement.parseFunctionParams)(allowModifiers, funcContextId);
  parseFunctionBodyAndFinish(
    functionStart,
    isGenerator,
    null /* allowExpressionBody */,
    funcContextId,
  );
  const endTokenIndex = _base.state.tokens.length;
  _base.state.scopes.push(new (0, _state.Scope)(startTokenIndex, endTokenIndex, true));
} exports.parseMethod = parseMethod;

// Parse arrow function expression.
// If the parameters are provided, they will be converted to an
// assignable list.
 function parseArrowExpression(functionStart, startTokenIndex) {
  parseFunctionBody(functionStart, false /* isGenerator */, true);
  const endTokenIndex = _base.state.tokens.length;
  _base.state.scopes.push(new (0, _state.Scope)(startTokenIndex, endTokenIndex, true));
} exports.parseArrowExpression = parseArrowExpression;

 function parseFunctionBodyAndFinish(
  functionStart,
  isGenerator,
  allowExpressionBody = null,
  funcContextId,
) {
  if (_base.isTypeScriptEnabled) {
    (0, _typescript.tsParseFunctionBodyAndFinish)(functionStart, isGenerator, allowExpressionBody, funcContextId);
  } else if (_base.isFlowEnabled) {
    (0, _flow.flowParseFunctionBodyAndFinish)(functionStart, isGenerator, allowExpressionBody, funcContextId);
  } else {
    parseFunctionBody(functionStart, isGenerator, allowExpressionBody, funcContextId);
  }
} exports.parseFunctionBodyAndFinish = parseFunctionBodyAndFinish;

// Parse function body and check parameters.
 function parseFunctionBody(
  functionStart,
  isGenerator,
  allowExpression,
  funcContextId,
) {
  const isExpression = allowExpression && !(0, _index3.match)(_types3.TokenType.braceL);

  if (isExpression) {
    parseMaybeAssign();
  } else {
    (0, _statement.parseBlock)(true /* allowDirectives */, true /* isFunctionScope */, funcContextId);
  }
} exports.parseFunctionBody = parseFunctionBody;

// Parses a comma-separated list of expressions, and returns them as
// an array. `close` is the token type that ends the list, and
// `allowEmpty` can be turned on to allow subsequent commas with
// nothing in between them to be parsed as `null` (which is needed
// for array literals).

function parseExprList(close, allowEmpty = null) {
  let first = true;
  while (!(0, _index3.eat)(close)) {
    if (first) {
      first = false;
    } else {
      (0, _util.expect)(_types3.TokenType.comma);
      if ((0, _index3.eat)(close)) break;
    }
    parseExprListItem(allowEmpty);
  }
}

function parseExprListItem(allowEmpty) {
  if (allowEmpty && (0, _index3.match)(_types3.TokenType.comma)) {
    // Empty item; nothing more to parse for this item.
  } else if ((0, _index3.match)(_types3.TokenType.ellipsis)) {
    (0, _lval.parseSpread)();
    parseParenItem();
  } else {
    parseMaybeAssign(false, parseParenItem);
  }
}

// Parse the next token as an identifier.
 function parseIdentifier() {
  (0, _index3.next)();
  _base.state.tokens[_base.state.tokens.length - 1].type = _types3.TokenType.name;
} exports.parseIdentifier = parseIdentifier;

// Parses await expression inside async function.
function parseAwait() {
  parseMaybeUnary();
}

// Parses yield expression inside generator.
function parseYield() {
  (0, _index3.next)();
  if (!(0, _index3.match)(_types3.TokenType.semi) && !(0, _util.canInsertSemicolon)()) {
    (0, _index3.eat)(_types3.TokenType.star);
    parseMaybeAssign();
  }
}
