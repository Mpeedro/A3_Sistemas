"use strict"; function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } } function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }Object.defineProperty(exports, "__esModule", {value: true});var _flow = require('../plugins/flow');




var _typescript = require('../plugins/typescript');








var _index = require('../tokenizer/index');
var _types = require('../tokenizer/types');
var _base = require('./base');
var _expression = require('./expression');
var _util = require('./util');

 function parseSpread() {
  (0, _index.next)();
  (0, _expression.parseMaybeAssign)(false);
} exports.parseSpread = parseSpread;

 function parseRest(isBlockScope) {
  (0, _index.next)();
  parseBindingAtom(isBlockScope);
} exports.parseRest = parseRest;

 function parseBindingIdentifier() {
  (0, _expression.parseIdentifier)();
} exports.parseBindingIdentifier = parseBindingIdentifier;

// Parses lvalue (assignable) atom.
 function parseBindingAtom(isBlockScope) {
  switch (_base.state.type) {
    case _types.TokenType._this: {
      // In TypeScript, "this" may be the name of a parameter, so allow it.
      const oldIsType = (0, _index.pushTypeContext)(0);
      (0, _index.next)();
      (0, _index.popTypeContext)(oldIsType);
      return;
    }

    case _types.TokenType._yield:
    case _types.TokenType.name: {
      _base.state.type = _types.TokenType.name;
      parseBindingIdentifier();
      _base.state.tokens[_base.state.tokens.length - 1].identifierRole = isBlockScope
        ? _index.IdentifierRole.BlockScopedDeclaration
        : _index.IdentifierRole.FunctionScopedDeclaration;
      return;
    }

    case _types.TokenType.bracketL: {
      (0, _index.next)();
      parseBindingList(_types.TokenType.bracketR, isBlockScope, true /* allowEmpty */);
      return;
    }

    case _types.TokenType.braceL:
      (0, _expression.parseObj)(true, isBlockScope);
      return;

    default:
      throw (0, _util.unexpected)();
  }
} exports.parseBindingAtom = parseBindingAtom;

 function parseBindingList(
  close,
  isBlockScope,
  allowEmpty,
  allowModifiers = null,
) {
  let first = true;

  let hasRemovedComma = false;
  const firstItemTokenIndex = _base.state.tokens.length;

  while (!(0, _index.eat)(close)) {
    if (first) {
      first = false;
    } else {
      (0, _util.expect)(_types.TokenType.comma);
      // After a "this" type in TypeScript, we need to set the following comma (if any) to also be
      // a type token so that it will be removed.
      if (!hasRemovedComma && _base.state.tokens[firstItemTokenIndex].isType) {
        _base.state.tokens[_base.state.tokens.length - 1].isType = true;
        hasRemovedComma = true;
      }
    }
    if (allowEmpty && (0, _index.match)(_types.TokenType.comma)) {
      // Empty item; nothing further to parse for this item.
    } else if ((0, _index.eat)(close)) {
      break;
    } else if ((0, _index.match)(_types.TokenType.ellipsis)) {
      parseRest(isBlockScope);
      parseAssignableListItemTypes();
      (0, _util.expect)(close);
      break;
    } else {
      parseAssignableListItem(allowModifiers, isBlockScope);
    }
  }
} exports.parseBindingList = parseBindingList;

function parseAssignableListItem(allowModifiers, isBlockScope) {
  if (allowModifiers) {
    (0, _typescript.tsParseAccessModifier)();
    (0, _typescript.tsParseModifier)([_index.ContextualKeyword._readonly]);
  }

  parseMaybeDefault(isBlockScope);
  parseAssignableListItemTypes();
  parseMaybeDefault(isBlockScope, true /* leftAlreadyParsed */);
}

function parseAssignableListItemTypes() {
  if (_base.isFlowEnabled) {
    (0, _flow.flowParseAssignableListItemTypes)();
  } else if (_base.isTypeScriptEnabled) {
    (0, _typescript.tsParseAssignableListItemTypes)();
  }
}

// Parses assignment pattern around given atom if possible.
 function parseMaybeDefault(isBlockScope, leftAlreadyParsed = false) {
  if (!leftAlreadyParsed) {
    parseBindingAtom(isBlockScope);
  }
  if (!(0, _index.eat)(_types.TokenType.eq)) {
    return;
  }
  (0, _expression.parseMaybeAssign)();
} exports.parseMaybeDefault = parseMaybeDefault;
