"use strict"; function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } } function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }Object.defineProperty(exports, "__esModule", {value: true});var _index = require('../tokenizer/index');
var _types = require('../tokenizer/types');
var _whitespace = require('../util/whitespace');
var _base = require('./base');

// ## Parser utilities

// Tests whether parsed token is a contextual keyword.
 function isContextual(contextualKeyword) {
  return _base.state.contextualKeyword === contextualKeyword;
} exports.isContextual = isContextual;

 function isLookaheadContextual(contextualKeyword) {
  const l = (0, _index.lookaheadTypeAndKeyword)();
  return l.type === _types.TokenType.name && l.contextualKeyword === contextualKeyword;
} exports.isLookaheadContextual = isLookaheadContextual;

// Consumes contextual keyword if possible.
 function eatContextual(contextualKeyword) {
  return _base.state.contextualKeyword === contextualKeyword && (0, _index.eat)(_types.TokenType.name);
} exports.eatContextual = eatContextual;

// Asserts that following token is given contextual keyword.
 function expectContextual(contextualKeyword) {
  if (!eatContextual(contextualKeyword)) {
    unexpected(null);
  }
} exports.expectContextual = expectContextual;

// Test whether a semicolon can be inserted at the current position.
 function canInsertSemicolon() {
  return (0, _index.match)(_types.TokenType.eof) || (0, _index.match)(_types.TokenType.braceR) || hasPrecedingLineBreak();
} exports.canInsertSemicolon = canInsertSemicolon;

 function hasPrecedingLineBreak() {
  const prevToken = _base.state.tokens[_base.state.tokens.length - 1];
  const lastTokEnd = prevToken ? prevToken.end : 0;
  return _whitespace.lineBreak.test(_base.input.slice(lastTokEnd, _base.state.start));
} exports.hasPrecedingLineBreak = hasPrecedingLineBreak;

 function isLineTerminator() {
  return (0, _index.eat)(_types.TokenType.semi) || canInsertSemicolon();
} exports.isLineTerminator = isLineTerminator;

// Consume a semicolon, or, failing that, see if we are allowed to
// pretend that there is a semicolon at this position.
 function semicolon() {
  if (!isLineTerminator()) unexpected(null, 'Unexpected token, expected";"');
} exports.semicolon = semicolon;

// Expect a token of a given type. If found, consume it, otherwise,
// raise an unexpected token error at given pos.
 function expect(type, pos) {
  const matched = (0, _index.eat)(type);
  if (!matched) {
    unexpected(pos, `Unexpected token, expected "${(0, _types.formatTokenType)(type)}"`);
  }
} exports.expect = expect;

// Raise an unexpected token error. Can take the expected token type
// instead of a message string.
 function unexpected(pos = null, message = "Unexpected token") {
  throw (0, _base.raise)(pos != null ? pos : _base.state.start, message);
} exports.unexpected = unexpected;
