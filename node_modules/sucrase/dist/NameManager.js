"use strict"; function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } } function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }Object.defineProperty(exports, "__esModule", {value: true});var _types = require('./parser/tokenizer/types');


 class NameManager {
  

  constructor( tokens) {;this.tokens = tokens;this.usedNames = new Set();}

  preprocessNames() {
    for (let i = 0; i < this.tokens.tokens.length; i++) {
      if (this.tokens.matchesAtIndex(i, [_types.TokenType.name])) {
        this.usedNames.add(this.tokens.identifierNameAtIndex(i));
      }
    }
  }

  claimFreeName(name) {
    const newName = this.findFreeName(name);
    this.usedNames.add(newName);
    return newName;
  }

  findFreeName(name) {
    if (!this.usedNames.has(name)) {
      return name;
    }
    let suffixNum = 2;
    while (this.usedNames.has(name + suffixNum)) {
      suffixNum++;
    }
    return name + suffixNum;
  }
} exports.default = NameManager;
